{"data":{"site":{"siteMetadata":{"title":"Canastro's notes","author":"Ricardo Canastro"}},"markdownRemark":{"id":"e412d619-ae28-57e6-82e4-11c8b269db87","excerpt":"At  dashdash  we build spreadsheets with super-powers, we aim to create tools that make computation accessible to everyone. Our spreadsheets support the…","html":"<p>At <a href=\"https://www.dashdash.com\">dashdash</a> we build spreadsheets with super-powers, we aim to create tools that make computation accessible to everyone.</p>\n<p>Our spreadsheets support the standard excel formulas, external API integration formulas and some dashdash formulas that allow you to integrate any API through GET and POST requests. Given this flexibility most of our computation has to be done in the backend, but not all of it. For the regular formulas that do not require HTTP requests to be fired, we could easily do them in the frontend.</p>\n<p>Currently we do all the computation on the backend, that means that even the “trival” operations such as <strong>SUM</strong> between two cells need to go the backend, and these are operations we, as users, expect to be immediate. </p>\n<h1>Optimistic Updates</h1>\n<p>One of the big challenges we have is what we call <strong>double computation</strong>. We want to do frontend optimistic updates to the basic operations (which do not include external requests) while still firing the backend requests to persist the computed values and then match and merge the results in the frontend.</p>\n<p>While basic users, usually have simple spreadsheets and their cell dependencies graph is rather simple, we don’t pose limits, and therefore the complexity of computation is unknown. If a user edits a cell that has a ripple effect that affets 1000 other cells, that will produce some heavy computation on the frontend. If we execute those operations by iterating a array of operations or with a recursive method, it will be a blocking operation and the browser will not be responsive during that process.</p>\n<h1>Requirements</h1>\n<ul>\n<li>No dropped frames, the page should be responsive at all times</li>\n<li>Processing should be interruptable (either because new data was introduced or user wants to leave the page)</li>\n<li>Should be as fast as possible given the previous constraints</li>\n<li>Relatively easy to maintain and to reason with</li>\n</ul>\n<h1>How to test our solutions</h1>\n<ul>\n<li>Create a simple example;</li>\n<li>Use <a href=\"https://github.com/sw-yx/async-render-toolbox\">async-render-toolbox</a> chrome extensions to have a visual cue of the CPU lag;</li>\n<li>Create a counter to make sure page is still interactive while processing a queue;</li>\n<li>Use devtools for some extra performance inspection;</li>\n</ul>\n<h1>Test case</h1>\n<p>A spreadsheet that A1=99 and each row from A2 to A2000 adds 10 the previous row. A2 will be computed to 109, A3 to 119, etc. A2000 will be 99+(10*1999) = 20 089. As you can imagine, changing the value of A1 will have a ripple effect and 1999 calcs would have to be done, <strong>sequentially</strong>. </p>\n<h1>Approaches</h1>\n<p>There are a few possible aproaches, but for this blog post I would like to explore one in particular, the usage of cpu idle callbacks to schedule work.</p>\n<h1>Data structure</h1>","frontmatter":{"title":"Heavy browser computation at dashdash","subtitle":null,"date":"January 11, 2019"}}},"pageContext":{"tags":[{"text":"javascript","link":"/tags/javascript/"},{"text":"dashdash","link":"/tags/dashdash/"}],"slug":"/2019-01-11---heavy-browser-computation/","previous":{"fields":{"slug":"/2019-01-09---ts-extend-modify/"},"frontmatter":{"title":"Typescript - Extending and modifying existing types with Mapped Types","path":"/ts-mapped-types","tags":["react","typescript"]}},"next":null}}