{"data":{"site":{"siteMetadata":{"title":"Canastro's notes","author":"Ricardo Canastro"}},"markdownRemark":{"id":"e412d619-ae28-57e6-82e4-11c8b269db87","excerpt":"At  dashdash  we build spreadsheets with super-powers, we aim to create tools that make computation accessible to everyone. Our spreadsheets support the…","html":"<p>At <a href=\"https://www.dashdash.com\">dashdash</a> we build spreadsheets with super-powers, we aim to create tools that make computation accessible to everyone.</p>\n<p>Our spreadsheets support the standard excel formulas, external API integration formulas and some dashdash formulas that allow you to integrate any API through GET and POST requests. Given this flexibility most of our computation has to be done in the backend, but not all of it. For the regular formulas that do not require HTTP requests to be fired, we could easily do them in the frontend.</p>\n<p>Currently we do all the computation on the backend, that means that even the “trival” operations such as <strong>SUM</strong> between two cells need to go the backend, and these are operations we, as users, expect to be immediate. </p>\n<h1>Optimistic Updates</h1>\n<p>One of the big challenges we have is what we call <strong>double computation</strong>. We want to do frontend optimistic updates to the basic operations (which do not include external requests) while still firing the backend requests to persist the computed values and then match and merge the results in the frontend.</p>\n<p>While basic users, usually have simple spreadsheets and their cell dependencies graph is rather simple, we don’t pose limits, and therefore the complexity of computation is unknown. If a user edits a cell that has a ripple effect that affets 1000 other cells, that will produce some heavy computation on the frontend. If we execute those operations by iterating a array of operations or with a recursive method, it will be a blocking operation and the browser will not be responsive during that process.</p>\n<h1>Requirements</h1>\n<ul>\n<li>No dropped frames, the page should be responsive at all times</li>\n<li>Processing should be interruptable (either because new data was introduced or user wants to leave the page)</li>\n<li>UI should be updated only when full computation is complete</li>\n<li>Should be as fast as possible given the previous constraints</li>\n<li>Relatively easy to maintain and to reason with</li>\n</ul>\n<h1>How to test our solutions</h1>\n<ul>\n<li>Create a simple example;</li>\n<li>Use <a href=\"https://github.com/sw-yx/async-render-toolbox\">async-render-toolbox</a> chrome extensions to have a visual cue of the CPU lag;</li>\n<li>Create a counter to make sure page is still interactive while processing a queue;</li>\n<li>Use devtools for some extra performance inspection;</li>\n</ul>\n<h1>Test case</h1>\n<p>A spreadsheet in which A1=99 and each row from A2 to A2000000 adds 10 the previous row. A2 will be computed to 109, A3 to 119, etc. A2000000 will be <code class=\"language-text\">99 + (10 * 1 999 999) = 20 000 089</code>. As you can imagine, changing the value of A1 will have a ripple effect and 1999 calcs would have to be done, <strong>sequentially</strong>. </p>\n<p>We need to define a datastructure and a traversal algorithm to test our solutions. Since the problem we’re tackling is only related with high CPU usage, we can easily create such scenario without a complex algorithm or data strucuture. We can easily create a object with each cell indexed by id a iterate it by starting with A1 and following to the next child cell until we find a cell without child.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">A1</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      id<span class=\"token punctuation\">:</span> <span class=\"token string\">'A1'</span><span class=\"token punctuation\">,</span>\n      child<span class=\"token punctuation\">:</span> <span class=\"token string\">'A2'</span><span class=\"token punctuation\">,</span>\n      formula<span class=\"token punctuation\">:</span> <span class=\"token number\">99</span><span class=\"token punctuation\">,</span>\n      value<span class=\"token punctuation\">:</span> <span class=\"token number\">99</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token constant\">A2</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n      id<span class=\"token punctuation\">:</span> <span class=\"token string\">'A2'</span><span class=\"token punctuation\">,</span>\n      child<span class=\"token punctuation\">:</span> <span class=\"token string\">'A3'</span><span class=\"token punctuation\">,</span>\n      formula<span class=\"token punctuation\">:</span> <span class=\"token string\">'=A1+10'</span><span class=\"token punctuation\">,</span>\n      value<span class=\"token punctuation\">:</span> <span class=\"token keyword\">null</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In each iteration we’re going to update the value of the cell and then move to the next one.</p>\n<h1>Approaches</h1>\n<p>There are a few possible aproaches, but for this blog post I would like to explore one in particular, the usage of <strong>cpu idle callbacks to schedule work</strong>.</p>","frontmatter":{"title":"Heavy browser computation at dashdash","subtitle":null,"date":"January 11, 2019"}}},"pageContext":{"tags":[{"text":"javascript","link":"/tags/javascript/"},{"text":"dashdash","link":"/tags/dashdash/"}],"slug":"/2019-01-11---heavy-browser-computation/","previous":{"fields":{"slug":"/2019-01-09---ts-extend-modify/"},"frontmatter":{"title":"Typescript - Extending and modifying existing types with Mapped Types","path":"/ts-mapped-types","tags":["react","typescript"]}},"next":null}}